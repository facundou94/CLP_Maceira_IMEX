}
#
#
############### LIMPIEZA  ##############################################################################################
############### Y TRANSFORMACIÓN #######################################################################################
############### DE ESPECTROS ###########################################################################################
#
#
#
#### SCREENING INICIAL #################################################################################################
# detección de espectros de baja calidad
#
sc.results <- screenSpectra(Spectra_list, meta = df_metadata)
summary(sc.results)
plot(sc.results, labels = TRUE)
#
# Ploteo que no pasan control de calidad y uno correcto (Aprox 6%, bien)
# plot(Spectra_list[[253]]) # Espectro muy ruidoso
#
## Descartamos espectros defectuosos
#
Spectra_list_f1 <- sc.results$fspectra # Filtramos espectros
df_metadata_f1 <- sc.results$fmeta # Filtramos metadatos
#
#
####### PROCESAMIENTO Y FILTRADO DE ESPECTROS ##########################################################################
# Parámetros de procesamiento de espectros
#
thScale <- 10 # Smoothing
#smoothLevel <- 4 # Wavelet smoothing level
ite <- 105 # Baseline correction
SigNoi <- 2.5 # Peak extraction
hws <- 20 # Peak extraction
tol <- 0.03 # Peak binning
#
# proceso correccion de espectros
# utiliza los parámetros definidos anteriormente
#
Spectra_list_f1 <- transfIntensity(Spectra_list_f1, fun = sqrt)
plot(Spectra_list_f1[[30]])
Spectra_list_f1 <- wavSmoothing(Spectra_list_f1, method = "Wavelet", n.levels = 4)
plot(Spectra_list_f1[[30]])
#spectra <- wavSmoothing(spectra, method = "Wavelet", n.levels = smoothLevel)
#
# Detección de la linea de base
#
baseline <- estimateBaseline(Spectra_list_f1[[30]], method = "SNIP",
iterations = ite)
plot(Spectra_list_f1[[30]])
lines(baseline, col="red", lwd=2)
#
#
Spectra_list_f2 <- removeBaseline(Spectra_list_f1, method = "SNIP", iterations = ite)
plot(Spectra_list_f2[[30]])
Spectra_list_f2 <- calibrateIntensity(Spectra_list_f2, method = "PQN")
plot(Spectra_list_f2[[30]])
Spectra_list_f3 <- alignSpectra(Spectra_list_f2,
halfWindowSize=20,
SNR=2,
tolerance=0.02, #Ojo, ver parámetros
warpingMethod="lowess")
#
plot(Spectra_list_f3[[30]])
gc()
plot(Spectra_list_f3[[300]])
plot(Spectra_list_f3[[299]])
plot(Spectra_list_f3[[298]])
plot(Spectra_list_f3[[297]])
plot(Spectra_list_f3[[296]])
plot(Spectra_list_f3[[295]])
plot(Spectra_list_f3[[294]])
plot(Spectra_list_f3[[293]])
plot(Spectra_list_f3[[292]])
plot(Spectra_list_f3[[300]])
plot(Spectra_list_f3[[300]])
plot(Spectra_list_f3[[299]])
plot(Spectra_list_f3[[298]])
plot(Spectra_list_f3[[297]])
plot(Spectra_list_f3[[296]])
plot(Spectra_list_f3[[295]])
plot(Spectra_list_f3[[294]])
plot(Spectra_list_f3[[293]])
plot(Spectra_list_f3[[292]])
plot(Spectra_list_f3[[291]])
#Por control empírico
indices_a_preservar <- c(1:296, 299:300)
Spectra_list_f3 <- Spectra_list_f3[[indices_a_preservar]]
#Por control empírico
indices_a_preservar <- c(1:296, 299:300)
Spectra_list_f3 <- Spectra_list_f3[indices_a_preservar]
################ MALDI-TOF ANALISIS CLP #####################################################################################
##
##
## Autor: Bioing. Facundo Urteaga (IBB-CONICET)
##
##
##################### CARGA DE LIBRERIAS ####################################################################################
#
#
library(here)
library(dplyr)
library(readBrukerFlexData)
library(MALDIquant)
library(MALDIquantForeign)
library(MALDIrppa)
library(stringr)
#
#
##################### CARGA DE ESPECTROS ####################################################################################
#
#
# Creación de la ruta relativa de los archivos
#
#ruta_proyecto <- here("OneDrive","Documents","Proyectos RStudio","Maceira_CLP","Datos CLP-SHAM D1-2-4-7")
ruta_proyecto <- here("Datos CLP-SHAM D1-2-4-7")
ruta_datos <- file.path(ruta_proyecto)
#
# Importar espectros
Spectra_list <- importBrukerFlex(file.path(ruta_datos), verbose=FALSE)
#
# Lectura de nombre de espectros, características y ploteo (Opcional/Chequeo)
#
#for(i in 1:length(Spectra_list)) {
#  print(Spectra_list[[i]]@metaData$sampleName)
#}
#summarySpectra(Spectra_list[1:10])
#plot(Spectra_list[[1]])
#
#
###### OBTENCIÓN DE METADATA DE ESPECTROS ###################################################################################
#
# Creación de columnas vacías
#
col_dia <- c()
col_tipo <- c()
col_numero <- c()
col_well <- c()
col_rep <- c()
#
# Patrones auxiliares para buscar el día de la muestra
patron <- "D1-2-4-7"
patron2 <- "D(1|2|4|7)"
# Patrón para extraer el nombre (todo antes de los números)
patron_nombre <- "^[A-Za-z]+"
# Patrón para extraer el número (todo después de las letras)
patron_numero <- "\\d+$"
#
# Ciclo que se encarga de extraer dia, tipo, numero, well y réplica de cada muestra
#
for(i in 1:length(Spectra_list)) {
nombre <- Spectra_list[[i]]@metaData$file
# Encuentra la posición del patrón en el texto
posicion <- str_locate(nombre, patron)[1, 2]
# Extrae la parte de la ruta después del patrón
resultado <- substr(nombre, (posicion+2), nchar(nombre))
resultado <- str_extract(resultado, patron2)
col_dia <- c(col_dia, resultado)
partes <- unlist(strsplit(Spectra_list[[i]]@metaData$sampleName, "_+"))
tipo <- str_extract(partes[1], patron_nombre)
numero <- str_extract(partes[1], patron_numero)
col_tipo <- c(col_tipo, tipo)
col_numero <- c(col_numero, numero)
col_well <- c(col_well, partes[2])
col_rep <- c(col_rep, partes[3])
}
#
#
# Data Frame con los datos limpios
#
df_metadata <- data.frame(dia = col_dia, tipo = col_tipo, numero = col_numero, well = col_well,
replica = col_rep)
#
# Creación de factores de agrupamiento para su uso posterior
#
df_metadata$factor1 <- paste0(df_metadata$tipo, "_", df_metadata$dia)
df_metadata$factor2 <- paste0(df_metadata$tipo, "_", df_metadata$dia, "_", df_metadata$numero)
df_metadata$factor3 <- paste0(df_metadata$tipo, "_", df_metadata$dia, "_", df_metadata$numero, "_", df_metadata$well)
#
#
######### ASIGNAR A METADATA DE ESPECTROS ##############################################################################
#
#
# Creo nueva metaData en espectro
for(i in 1:length(Spectra_list)) {
Spectra_list[[i]]@metaData$tipo = df_metadata$tipo[i]
Spectra_list[[i]]@metaData$dia = df_metadata$dia[i]
Spectra_list[[i]]@metaData$numero = df_metadata$numero[i]
Spectra_list[[i]]@metaData$well = df_metadata$well[i]
Spectra_list[[i]]@metaData$replica = df_metadata$replica[i]
Spectra_list[[i]]@metaData$factor1 = df_metadata$factor1[i]
Spectra_list[[i]]@metaData$factor2 = df_metadata$factor2[i]
Spectra_list[[i]]@metaData$factor3 = df_metadata$factor3[i]
}
#
#
############### LIMPIEZA  ##############################################################################################
############### Y TRANSFORMACIÓN #######################################################################################
############### DE ESPECTROS ###########################################################################################
#
#
#
#### SCREENING INICIAL #################################################################################################
# detección de espectros de baja calidad
#
sc.results <- screenSpectra(Spectra_list, meta = df_metadata)
summary(sc.results)
plot(sc.results, labels = TRUE)
#
# Ploteo que no pasan control de calidad y uno correcto (Aprox 6%, bien)
# plot(Spectra_list[[253]]) # Espectro muy ruidoso
#
## Descartamos espectros defectuosos
#
Spectra_list_f1 <- sc.results$fspectra # Filtramos espectros
df_metadata_f1 <- sc.results$fmeta # Filtramos metadatos
#
#
####### PROCESAMIENTO Y FILTRADO DE ESPECTROS ##########################################################################
# Parámetros de procesamiento de espectros
#
thScale <- 10 # Smoothing
#smoothLevel <- 4 # Wavelet smoothing level
ite <- 105 # Baseline correction
SigNoi <- 2.5 # Peak extraction
hws <- 20 # Peak extraction
tol <- 0.03 # Peak binning
#
# proceso correccion de espectros
# utiliza los parámetros definidos anteriormente
#
Spectra_list_f1 <- transfIntensity(Spectra_list_f1, fun = sqrt)
plot(Spectra_list_f1[[30]])
Spectra_list_f1 <- wavSmoothing(Spectra_list_f1, method = "Wavelet", n.levels = 4)
plot(Spectra_list_f1[[30]])
#spectra <- wavSmoothing(spectra, method = "Wavelet", n.levels = smoothLevel)
#
# Detección de la linea de base
#
baseline <- estimateBaseline(Spectra_list_f1[[30]], method = "SNIP",
iterations = ite)
plot(Spectra_list_f1[[30]])
lines(baseline, col="red", lwd=2)
#
#
Spectra_list_f2 <- removeBaseline(Spectra_list_f1, method = "SNIP", iterations = ite)
plot(Spectra_list_f2[[30]])
Spectra_list_f2 <- calibrateIntensity(Spectra_list_f2, method = "PQN")
plot(Spectra_list_f2[[30]])
Spectra_list_f3 <- alignSpectra(Spectra_list_f2,
halfWindowSize=20,
SNR=2,
tolerance=0.02, #Ojo, ver parámetros
warpingMethod="lowess")
#
plot(Spectra_list_f3[[30]])
#
#Por control empírico
indices_a_preservar <- c(1:296, 299)
Spectra_list_f3 <- Spectra_list_f3[indices_a_preservar]
df_metadata_f1 <- df_metadata_f1[indices_a_preservar]
df_metadata_f1 <- df_metadata_f1 %>%
slice(indices_a_preservar)
Spectra_list_prom_rep <- averageMassSpectra(Spectra_list_f3,
labels = factor(df_metadata_f1$factor3),
method = "mean")
#
#
plot(Spectra_list_prom_rep[[123]])
plot(Spectra_list_prom_rep[[122]])
# Creo la nueva metadata de los espectros promediados
#
#
df_metadata_prom_rep <- df_metadata_f1 %>%
distinct(factor3, .keep_all = TRUE)
#
#
# Parte de relacion señal a ruido
#
noise <- estimateNoise(Spectra_list_prom_rep[[123]])
# Parte de relacion señal a ruido
#
noise <- estimateNoise(Spectra_list_prom_rep[[122]])
plot(Spectra_list_prom_rep[[123]], xlim=c(4000, 20000), ylim=c(0, 0.0005))
# Parte de relacion señal a ruido
#
noise <- estimateNoise(Spectra_list_prom_rep[[122]])
plot(Spectra_list_prom_rep[[122]], xlim=c(4000, 20000), ylim=c(0, 0.0005))
lines(noise, col="red")
lines(noise[,1], noise[, 2]*2, col="blue") # Se ve que es correcto el 2
#
#
####### EXTRACCIÓN DE PICOS Y ALINEACIÓN ###############################################################
#
peaks <- detectPeaks(Spectra_list_prom_rep,
SNR = SigNoi,
halfWindowSize = 40)
plot(Spectra_list_prom_rep[[123]], xlim=c(4000, 20000), ylim=c(0, 0.0005))
####### EXTRACCIÓN DE PICOS Y ALINEACIÓN ###############################################################
#
peaks <- detectPeaks(Spectra_list_prom_rep,
SNR = SigNoi,
halfWindowSize = 40)
plot(Spectra_list_prom_rep[[122]], xlim=c(4000, 20000), ylim=c(0, 0.0005))
points(peaks[[122]], col="red", pch=4)
peaks <- alignPeaks(peaks,
minFreq = 0.8,
tolerance = tol)
summaryPeaks(peaks[1:10])  # resumen estadistico de picos (primeros 10)
#
#
## conteo de picos por perfil
#
cP <- countPeaks(peaks)
#
# gráfico
#
plot(cP, type = "n")
text(cP, label = 1:length(cP)) # Se encuentran muestras 123 y 122 extrañas
#
View(df_metadata_prom_rep)
View(df_metadata_prom_rep)
## Patrones de picos
peakPatterns(peaks)
## Filtrado de picos de baja frecuencia de aparición
picos_filtrados <- filterPeaks(peaks,
minFreq = 0.25,
labels = df_metadata_prom_rep$factor1 ) #EVALUAR QUE PARÁMETRO DE FILTRADO USAR
#OJO CON ESO,id paciente es mejor, pero pierdo info?
peakPatterns(picos_filtrados)
## conteo de picos por perfil
#
cP2 <- countPeaks(picos_filtrados)
#
# gráfico
#
plot(cP2, type = "n")
text(cP2, label = 1:length(cP2)) # Se encuentran muestras 123 y 122 extrañas
View(df_metadata_prom_rep)
# Fusion de picos de la misma muestra (!!! me quedo con pocas muestras)
picos_fusion_muestra <- mergeMassPeaks(picos_filtrados,
labels = df_metadata_prom_rep$factor2,
method = "median")
peakPatterns(picos_fusion_muestra)
################ MALDI-TOF ANALISIS CLP ########################################
################ 5) ns_m51_d24  ################################################
#
# ns:    No Supervisado
# m51:  Utiliza las muestras (51)
# d1247: Utiliza los días 2 y 4
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library("readBrukerFlexData")
library("binda")
library("fs")
library("readxl")
library("MALDIquant")
library("MALDIquantForeign")
library("MALDIrppa")
library("tidyverse")
library("dplyr")
library("clValid")
library(cluster)
library(factoextra)
### CARGA DE ARCHIVOS ##########################################################
################################################################################
#script_path <- "C:/Users/Facundo/Documents/Proyectos/Data"
#setwd(script_path) session -> set working directory
load("matint_51_dico.Rdata")
setwd("C:/Users/Facundo/Documents/Proyectos/Maceira_CLP/Data")
################ MALDI-TOF ANALISIS CLP ########################################
################ 5) ns_m51_d24  ################################################
#
# ns:    No Supervisado
# m51:  Utiliza las muestras (51)
# d1247: Utiliza los días 2 y 4
#
# Autor: Bioing. Facundo Urteaga (IBB-CONICET)
#
#
### CARGA DE LIBRERIAS #########################################################
################################################################################
library("readBrukerFlexData")
library("binda")
library("fs")
library("readxl")
library("MALDIquant")
library("MALDIquantForeign")
library("MALDIrppa")
library("tidyverse")
library("dplyr")
library("clValid")
library(cluster)
library(factoextra)
### CARGA DE ARCHIVOS ##########################################################
################################################################################
#script_path <- "C:/Users/Facundo/Documents/Proyectos/Data"
#setwd(script_path) session -> set working directory
load("matint_51_dico.Rdata")
load("matint_51.Rdata")
df_metadata_unicas$dia <- as.integer(gsub("[^0-9]", "",
df_metadata_unicas$dia))
# Filtrado de muestras de día 2 y día 4 y agrupo los SH
filas_filtradas <- rownames(matint_51_dico)[grepl("D2|D4", rownames(matint_51_dico))]
matint_51_dico_d2d4 <- matint_51_dico[filas_filtradas, ]
df_unicas_d2d4 <- df_metadata_unicas %>%
dplyr::filter(dia == 2 | dia == 4)
df_unicas_d2d4 <- df_unicas_d2d4 %>%
mutate(factor1 = ifelse(grepl("SH", factor1), "SH", factor1))
filas_filtradas <- rownames(matint_51)[grepl("D2|D4", rownames(matint_51))]
matint_51_d2d4 <- matint_51[filas_filtradas, ]
### SELECCIÓN DE PICOS #########################################################
################################################################################
factor_tipo <- factor(df_unicas_d2d4$factor1)
is.binaryMatrix(matint_51_dico_d2d4) # TRUE
br <- binda.ranking(matint_51_dico_d2d4, factor_tipo, verbose = FALSE)
indices_especificos <- br[1:20]
# Gráfico de picos vs score
nueva_columna <- c()
matriz <- matrix(br, nrow = 218, ncol = 4)
for (i in 1:218) {
nuevo_valor <- colnames(matint_51_dico_d2d4)[br[i]]
nueva_columna<- c(nueva_columna, nuevo_valor)
}
matriz <- cbind(matriz, nueva_columna)
df_br <- data.frame(matriz)
plot(df_br$nueva_columna, df_br$V2,
xlab = "m/z", ylab = "Score",
main = "Ranking de picos de los espectros CLP_D2 vs CLP_D4 vs SH")
# Crear un gradiente de colores (por ejemplo, de azul a rojo)
colores <- colorRampPalette(c("blue", "red"))(218)
# Agregar puntos con colores en forma de gradiente
for (i in 1:218) {
points(df_br$nueva_columna[i], df_br$V2[i], col = colores[i])
}
# Agregar puntos con relleno de colores en forma de gradiente
for (i in 1:218) {
points(df_br$nueva_columna[i], df_br$V2[i], pch = 19, col = colores[i])
}
# Selección de picos mas preponderantes
top.b10 <- br[1:10]  ## primeros 10 picos
top.b15 <- br[1:15]  ## primeros 15 picos
top.b20 <- br[1:20]  ## primeros 20 picos
top.b30 <- br[1:30]  ## primeros 30 picos
top_actual <- top.b10 # Ir probando
# Elección de mejores algoritmos de clustering
comparacion <- clValid(
obj        = matint_51_dico_d2d4[, top_actual],
nClust     = 2:6,
clMethods  = c("hierarchical", "kmeans", "pam"),
validation = c("stability", "internal")
)
summary(comparacion)
optimalScores(comparacion)
### ALGORITMOS DE CLUSTERING ###################################################
################################################################################
# Con top15: HKMEANS clustering 3 clusters
top_actual <- top.b15
K.num <- 3 # clusters
var2 = 0.95
hkmeans.top15.k3 <- hkmeans(matint_51_dico_d2d4[, top_actual],
K.num)
cluster.hkmeans.top15.k3 <- fviz_cluster(hkmeans.top15.k3, ellipse.type = "convex",
data = matint_51_dico_d2d4[, top_actual],
ellipse.level = var2,
show.clust.cent = F,
geom = "point",
main = "hkmeans - Top 15 - 3 clusters")
# Ajustar el tamaño de los puntos según los valores de la columna "dia"
cluster.hkmeans.top15.k3 <- cluster.hkmeans.top15.k3 +
geom_point(data = cluster.hkmeans.top15.k3$data,
aes(x = x, y = y, color = df_unicas_d2d4$factor1,
size = df_unicas_d2d4$dia)) +
scale_color_manual(values = c("maroon1","aquamarine3","blueviolet", "blue1",
"blue4", "maroon4")) +
scale_size_continuous(range = c(2, 3)) +
labs(color = "Cluster", size = "Día") +
theme(legend.position = "right")
print(cluster.hkmeans.top15.k3)
# Con top15: PAM clustering 3 clusters
top_actual <- top.b15
K.num <- 3 # clusters
var2 = 0.95
pam.top15.k3 <- pam(matint_51_dico_d2d4[, top_actual], metric = "manhattan",
K.num)
cluster.pam.top15.k3 <- fviz_cluster(pam.top15.k3, ellipse.type = "convex",
data = matint_51_dico_d2d4[, top_actual],
ellipse.level = var2,
show.clust.cent = F,
geom = "point",
main = "PAM - Top 15 - 3 clusters")
# Ajustar el tamaño de los puntos según los valores de la columna "dia"
cluster.pam.top15.k3 <- cluster.pam.top15.k3 +
geom_point(data = cluster.pam.top15.k3$data,
aes(x = x, y = y, color = df_unicas_d2d4$factor1,
size = df_unicas_d2d4$dia)) +
scale_color_manual(values = c("maroon1","aquamarine3","blueviolet", "blue1",
"blue4", "maroon4")) +
scale_size_continuous(range = c(2, 3)) +
labs(color = "Cluster", size = "Día") +
theme(legend.position = "right")
print(cluster.pam.top15.k3)
### EXPORTAR MATRICES CON 15 PICOS DE INTERÉS ##################################
################################################################################
write.csv(matint_51_dico_d2d4[, top_actual], "top15_43_dico_d24.csv", row.names = TRUE)
write.csv(matint_51_d2d4[, top_actual], "top15_43_d24.csv", row.names = TRUE)
write.csv(df_unicas_d2d4, "metadata_43.csv", row.names = TRUE)
### FIN ########################################################################
################################################################################
